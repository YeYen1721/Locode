# Loco — Technical Implementation Overview

Loco is a specialized security application designed to protect users from QR code phishing ("quishing") and malicious URLs through a combination of native interception, heuristic analysis, and Gemini-powered AI classification.

## 1. Core Architecture

The project follows a **Clean Architecture** pattern, separating concerns into distinct layers:

- **Data Layer**: Handles API communication (Supabase, Gemini), local storage (Hive, SharedPreferences), and URL resolving.
- **Domain Layer**: Contains business logic, entities, and use cases (e.g., `analyze_qr_code.dart`).
- **Presentation Layer**: Flutter-based UI utilizing a single-screen map layout with floating overlays.
- **Platform Layer**: Kotlin-based `MainActivity` for deep link handling and system-level notifications.

## 2. Key Technical Implementations

### A. Rebranding & Consitency
The app was fully transitioned from "SafeScan" to **Locode**. This involved:
- **Android**: Renaming package to `com.example.loco`, updating `applicationId`, and moving Kotlin source files.
- **iOS**: Updating `CFBundleDisplayName` and `PRODUCT_BUNDLE_IDENTIFIER`.
- **Flutter**: Renaming the package in `pubspec.yaml` and performing a global refactor of all `package:loco/` imports.

### B. URL Analysis Engine
The system uses a two-phase approach to classify URLs:
1. **Local Heuristics**: A Kotlin/Dart-based engine that checks for suspicious TLDs, brand typosquatting (Levenshtein distance), and sensitive keywords (login, verify, etc.).
2. **Gemini AI**: Uses `google_generative_ai` to perform deep analysis of the URL structure and resolved destination.

### C. Community Heatmap & Real-time Reports
- **Google Maps Integration**: A full-screen map displaying threat markers.
- **Supabase Real-time**: Listen to the `scams` table via Postgres Changes. When a new report is submitted by any user, a red marker appears on all active maps instantly.
- **Fuzzed Location**: For privacy, reported coordinates are fuzzed to 3 decimal places before being shared with the community.

### D. Deep Linking & Report Flow
- **Custom Scheme**: Registered `loco://report?url=...` to allow external triggers (like a "Report" button in a browser or notification) to open the app directly to the reporting interface.
- **MethodChannel Bridge**: Implemented `com.loco/scan` to pass the "last scanned URL" from the native side to Flutter, enabling one-tap reporting.

## 3. Critical Fixes (Nuclear Update)

### Infinite Restart Loop (OOM)
- **Problem**: A broad `http/https` intent filter was catching all system URLs, including those generated by the Google Maps SDK, causing the app to restart recursively (Engine count 1→2→3→4...) until crashing.
- **Fix**: Removed the broad intent filter. Interception is now handled via **Demo Scan** mode and `loco://` deep links. This stabilized the app and reduced memory usage significantly.

### Google Maps API Key
- **Problem**: Manifest placeholders were failing to read the key from `local.properties` in some build environments.
- **Fix**: Hardcoded the API key directly in `AndroidManifest.xml` for the hackathon demo and ensured the package name `com.example.loco` was authorized in the Google Cloud Console.

## 4. Primary File Structure

- `android/app/src/main/kotlin/com/example/loco/MainActivity.kt`: Native bridge and deep link entry.
- `lib/features/home/presentation/pages/home_page.dart`: The core UI, including the map, demo scan logic, and reporting sheets.
- `lib/services/notification_verdict.dart`: Handles native heads-up notifications with safety icons.
- `lib/features/scan/data/datasources/gemini_remote_datasource.dart`: Gemini AI integration.
- `lib/features/scan/data/datasources/local_heuristic_engine.dart`: The instant analysis logic.

## 5. Deployment & Execution
The app is built using Flutter 3.x and requires the following `--dart-define` flags:
- `GEMINI_API_KEY`
- `SUPABASE_URL`
- `SUPABASE_ANON_KEY`
